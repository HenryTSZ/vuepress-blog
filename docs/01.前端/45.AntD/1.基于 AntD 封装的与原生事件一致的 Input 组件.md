---
title: 基于 AntD 封装的与原生事件一致的 Input 组件
date: 2022-08-03 16:25:28
permalink: /pages/df4682/
categories:
  - 前端
  - AntD
tags:
  -
---

## 封装背景

antd 的 Input 只有 onChange 这一个数据变化的事件，而且是只要数据变化就触发；而原生 input 的 onchange 事件是在 input 失去焦点的时候才会触发，oninput 事件在用户输入时触发，它是在元素值发生变化时立即触发

所以 antd Input 的 onChange 其实是原生的 oninput 事件，没有 onchange 事件，而我们有时候是需要这种场景的

故需要封装一个与原生事件一致的的 Input 组件

## 定义 Props

```ts
import { InputProps } from 'antd/lib/input'

type Value = string | number

export interface RealInputProps extends Omit<InputProps, 'onChange' | 'onInput' | 'value'> {
  value: Value // 默认值
  onChange?: (value: string) => void // input 失去焦点的时候才会触发
  onInput?: (value: string) => void // 元素值发生变化时立即触发
}

interface State {
  value: Value
  oldValue: Value
}
```

Omit:

> `Construct a type with the properties of T except for those in type K.`
>
> `type Omit<T, K extends string | number | symbol> = { [P in Exclude<keyof T, K>]: T[P]; }`

## 在 state 中定义 value 与 oldValue，值都是 props.value

```ts
const { value, onChange, onInput, ...rest } = props
const valueTrim = `${value}`.trim()

const [state, updateState] = useImmer<State>({
  value: valueTrim,
  oldValue: valueTrim
})
```

## 监听 value，更新 state.value

```ts
useEffect(() => {
  updateState(draft => {
    draft.value = `${value}`.trim()
  })
}, [value])
```

## 监听 onChange 事件，回调里更新 state.value，并调用 onInput 回调

```ts
const handleChange = e => {
  const value = e.target.value
  updateState(draft => {
    draft.value = value
  })
  typeof onInput === 'function' && onInput(value)
}
```

## 监听 onBlur 事件，回调里判断 value 与 oldValue 是否相同，并做相应处理

```ts
const handleBlur = () => {
  let { oldValue, value } = state
  value = `${value}`.trim()
  updateState(draft => {
    draft.value = value
  })
  if (oldValue != value) {
    updateState(draft => {
      draft.oldValue = value
    })
    typeof onChange === 'function' && onChange(value)
  }
}
```

## 处理 ref 传递

```ts
export default forwardRef(RealInput)
```

## 完整代码

```ts
// RealInput
import React, { useEffect, forwardRef } from 'react'
import { useImmer } from 'use-immer'
import { Input, InputRef } from 'antd'
import { InputProps } from 'antd/lib/input'

type Value = string | number

export interface RealInputProps extends Omit<InputProps, 'onChange' | 'onInput' | 'value'> {
  value: Value // 默认值
  onChange?: (value: string) => void // input 失去焦点的时候才会触发
  onInput?: (value: string) => void // 元素值发生变化时立即触发
}

interface State {
  value: Value
  oldValue: Value
}

const RealInput = function (props: RealInputProps, ref: React.Ref<InputRef>) {
  const { value, onChange, onInput, ...rest } = props
  const valueTrim = `${value}`.trim()

  const [state, updateState] = useImmer<State>({
    value: valueTrim,
    oldValue: valueTrim
  })

  useEffect(() => {
    updateState(draft => {
      draft.value = `${value}`.trim()
    })
  }, [value])

  const handleChange = e => {
    const value = e.target.value
    updateState(draft => {
      draft.value = value
    })
    typeof onInput === 'function' && onInput(value)
  }

  const handleBlur = () => {
    let { oldValue, value } = state
    value = `${value}`.trim()
    updateState(draft => {
      draft.value = value
    })
    if (oldValue != value) {
      updateState(draft => {
        draft.oldValue = value
      })
      typeof onChange === 'function' && onChange(value)
    }
  }

  return (
    <Input
      className="real-input"
      value={state.value}
      ref={ref}
      onChange={handleChange}
      onBlur={handleBlur}
      {...rest}
    />
  )
}

export default forwardRef(RealInput)
```
